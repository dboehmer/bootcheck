##!/bin/sh

### ENVIRONMENT ###

# buit-in values:
ALGORITHMS="cksum md5sum sha1sum sha224sum sha256sum sha384sum sha512sum"
CONFIG_FILE="/etc/bootcheck.conf"
VERSION=1.0

SUCCESS=0
ERROR=1
WARNING=2
MOD_DETECTED=23

COLUMNS=$(tput cols)
LINES=$(tput lines)

# default configurable values:
action=warning
enable_debugging=0
enable_logging=0
enable_sha512sum=1
enable_logging=0
log_file=/var/log/bootcheck.log
storage=/var/lib/bootcheck
target=/boot



### USEFUL FUNCTIONS ###

# return calculated hash
hash() {
    # $1   hash algorithm as executable file (e.g. "md5sum")
    
    # target directory: hash files and hash the list of hashes
    [ -d "$target" ] && echo $($1 `find $target -type f` | $1 | cut -d " " -f 1)
    
    # target block device or regular file: hash the whole device
    ([ -b "$target" ] || [ -f "$target" ]) && echo $($1 $target | cut -d " " -f 1)
}

# calculate hash and store to a file with the algorithm's name
store() {
    # $1   hash algorithm
    # $tmp temporary working directory
    
    hash $1 > "$tmp/$1"
}

# calculate current hash and compare to old hash
check() {
    # $1   hash algorithm
    # $tmp temporary working directory
    
    current=$(hash $1)
    
    # hashes are equal
    [ "$current" == "$(cat $tmp/$1)" ] && return $SUCCESS
    
    # else: modified!
    return $MOD_DETECTED
}

# alert -- do action defined in config
alert() {
    echo "WOOHHHAAAAAA" >&2
}


### STARTUP ###

# load values given in config file if exists
# syntax is just like shell and can be sourced
[ -e $CONFIG_FILE ] && . $CONFIG_FILE

# sanity checks on startup
[ ! -b "$target" ] && [ ! -d "$target" ] && [ ! -f "$target" ] && {
    echo "Error: Target is neither block device nor directory nor regular file!"
    exit $ERROR
}

[ -r "$target" ] || {
    echo "Error: Target is not readable!"
    exit $ERROR
}

[ -d "$target" ] && [ ! -x "$target" ] && {
    echo "Error: Target directory is not accessable!"
    exit $ERROR
}

([ -d "$storage" ] && [ -r "$storage" ] && [ -x "$storage" ]) || {
    echo "Error: Storage directory $storage does not exist or is not accessable or readable!"
    exit $ERROR
}



### CASE 1: SYSTEM SHUTDOWN => STORE HASH OF TARGET DIR ###

if [ $# == 1 ] && [ "$1" == "--store" ]; then
    
    # check if target is empty and abort if so
    [ "$(ls -A $target)" ] || {
        echo "Error: $target directory empty!" >&2
        exit $ERROR
    }
    
    # create temporary directory
    tmp=$(mktemp --directory "/tmp/bootcheck.XXXXXXXXXX")

    [ -z $tmp ] && {
        echo "Error: Creation of temporary dir failed!" >&2
        return $ERROR
    }
    
    # run any algorithm enabled by config (default: only sha512sum)
    for algorithm in $ALGORITHMS; do
        [ "{enable_!algorithm}" ] && [ $(type -P $algorithm) ] && store $algorithm
    done

    [ $(ls -1A $tmp | wc -l) == 0 ] && {
        echo "Error: No hashes created!" >&2
        rmdir $tmp
        exit $ERROR
    }
    
    # store ad and information
    echo "Created by bootcheck $VERSION on $(date)" > $tmp/README
    echo $(date +%s) > $tmp/timestamp
    echo $target > $tmp/target
    echo $VERSION > $tmp/version
    
    # create hash package
    cd $tmp
    tar cf $storage/hash.tar *
    
    [ "$?" ] && {
        echo "Error: creation of hash tar failed!"
        cd /
        rm -r $tmp
        exit $ERROR
    }
    
    # delete temporary files
    cd /
    rm -r $tmp
    
    exit $SUCCESS
fi



### CASE 2: SYSTEM BOOTS UP => RECOGNIZE ANY MODIFICATIONS ###

if [ $# == 0 ]; then
    if [ ! -e "$storage/hash.tar" ]; then
        echo "Warning: No hash stored yet -- cannot check target!" >&2
        exit $WARNING
    fi
    
    tmp=$(mktemp --directory "/tmp/bootcheck.XXXXXXXXXX")

    [ -z $tmp ] && {
        echo "Error: Creation of temporary dir failed!" >&2
        return $ERROR
    }
    
    # extract old hash tar
    cd $tmp
    tar xf $storage/hash.tar
    
    # check the stored hash tar
    [ "$(cat $tmp/target)" == "$target" ] || {
        echo "Error: stored hash was calculated for a different target! Store new hash before next check."
        cd /
        rm -r $tmp
        exit $ERROR
    }
    
    # count var
    i=0
    
    # for any algorithm: check if hash is available and if so compare
    for algorithm in $ALGORITHMS; do
        if [ -e "$tmp/$algorithm" ] && [ $(type -P $algorithm) ]; then
            check $algorithm
            if [ "$?" == "$SUCCESS" ]; then
                # increase number of checks
                i=$[$i+1]
            else
                alert
                cd /
                rm -r $tmp
                exit $MOD_DETECTED
            fi
        fi
    done
    
    # clean up
    cd /
    rm -r $tmp
    
    if [ $i == 0 ]; then
        echo "Warning: Could NOT check for modifications by any algorithm due to missing hashes!" >&2
        exit $WARNING
    else
        echo "Info: Target checked by $i hash algorithms and proved to be unmodified."
        exit $SUCCESS
    fi
fi


### ELSE: NO VALID OPTIONS GIVEN => SHOW HELP ###

echo "Usage: $0 [--store]

    no args  check target directory now and print warning if modified

    --store  calculate hash of target directory and store it
             for recognizing modifications later on" >&2

exit $ERROR
